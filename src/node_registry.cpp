/**
 * @file node_registry.cpp
 * @brief 子节点注册表实现
 */

#include "node_registry.h"
#include <sys/stat.h>
#include <cerrno>

namespace sshjump {

namespace {

std::string boolToString(bool v) {
    return v ? "true" : "false";
}

bool parseBool(const std::string& rawValue, bool defaultValue) {
    const std::string value = trimString(rawValue);
    if (value == "true" || value == "1" || value == "yes" || value == "on") {
        return true;
    }
    if (value == "false" || value == "0" || value == "no" || value == "off") {
        return false;
    }
    return defaultValue;
}

} // namespace

bool ChildNodeRegistry::loadFromFile(const std::string& path) {
    std::ifstream file(path);
    if (!file.is_open()) {
        LOG_WARN("Child node file not found: " + path + ", starting with empty registry");
        return false;
    }

    NodeMap<std::string, ChildNodeInfo> loaded;
    ChildNodeInfo current;
    bool inNodeSection = false;

    std::string line;
    while (std::getline(file, line)) {
        line = trimString(line);
        if (line.empty() || line[0] == '#' || line[0] == ';') {
            continue;
        }

        if (line.front() == '[' && line.back() == ']') {
            if (inNodeSection) {
                trimNode(current);
                if (current.isValid()) {
                    loaded[current.nodeId] = current;
                } else if (!current.nodeId.empty()) {
                    LOG_WARN("Skipping invalid child node config: " + current.nodeId);
                }
            }

            inNodeSection = false;
            current = ChildNodeInfo{};

            const std::string section = line.substr(1, line.size() - 2);
            if (section.rfind("node:", 0) == 0) {
                inNodeSection = true;
                current.nodeId = trimString(section.substr(5));
            }
            continue;
        }

        if (!inNodeSection) {
            continue;
        }

        const size_t pos = line.find('=');
        if (pos == std::string::npos) {
            continue;
        }

        const std::string key = trimString(line.substr(0, pos));
        const std::string value = trimString(line.substr(pos + 1));

        if (key == "name") {
            current.name = value;
        } else if (key == "public_address") {
            current.publicAddress = value;
        } else if (key == "ssh_port") {
            current.sshPort = safeStringToInt(value, current.sshPort);
        } else if (key == "cluster_port") {
            current.clusterPort = safeStringToInt(value, current.clusterPort);
        } else if (key == "description") {
            current.description = value;
        } else if (key == "enabled") {
            current.enabled = parseBool(value, true);
        } else if (key == "created_at") {
            current.createdAt = parseTimestamp(value);
        } else if (key == "updated_at") {
            current.updatedAt = parseTimestamp(value);
        } else if (key.rfind("meta.", 0) == 0) {
            current.metadata[key.substr(5)] = value;
        }
    }

    if (inNodeSection) {
        trimNode(current);
        if (current.isValid()) {
            loaded[current.nodeId] = current;
        } else if (!current.nodeId.empty()) {
            LOG_WARN("Skipping invalid child node config: " + current.nodeId);
        }
    }

    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        nodes_.swap(loaded);
    }

    LOG_INFO("Loaded child nodes: " + std::to_string(size()));
    return true;
}

bool ChildNodeRegistry::saveToFile(const std::string& path) const {
    std::vector<ChildNodeInfo> nodes = listNodes(false);

    std::string dir = path;
    const size_t slash = dir.find_last_of('/');
    if (slash != std::string::npos) {
        dir = dir.substr(0, slash);
        if (!dir.empty()) {
            if (mkdir(dir.c_str(), 0700) != 0 && errno != EEXIST) {
                LOG_ERROR("Failed to create child node directory: " + dir +
                          ", err=" + std::string(strerror(errno)));
                return false;
            }
            chmod(dir.c_str(), 0700);
        }
    }

    std::ofstream file(path, std::ios::out | std::ios::trunc);
    if (!file.is_open()) {
        LOG_ERROR("Failed to open child node file for write: " + path);
        return false;
    }

    file << "# SSH Jump Child Nodes\n";
    file << "# Auto generated by ssh_jump_node_tool\n\n";

    for (const auto& node : nodes) {
        file << "[node:" << node.nodeId << "]\n";
        if (!node.name.empty()) {
            file << "name = " << node.name << "\n";
        }
        file << "public_address = " << node.publicAddress << "\n";
        file << "ssh_port = " << node.sshPort << "\n";
        file << "cluster_port = " << node.clusterPort << "\n";
        if (!node.description.empty()) {
            file << "description = " << node.description << "\n";
        }
        file << "enabled = " << boolToString(node.enabled) << "\n";
        file << "created_at = " << formatTimestamp(node.createdAt) << "\n";
        file << "updated_at = " << formatTimestamp(node.updatedAt) << "\n";
        for (const auto& kv : node.metadata) {
            file << "meta." << kv.first << " = " << kv.second << "\n";
        }
        file << "\n";
    }

    file.close();
    chmod(path.c_str(), 0600);
    return true;
}

bool ChildNodeRegistry::createNode(const ChildNodeInfo& inputNode, bool overwrite) {
    ChildNodeInfo node = inputNode;
    trimNode(node);
    if (!node.isValid()) {
        return false;
    }

    const auto now = std::chrono::system_clock::now();
    if (node.createdAt == std::chrono::system_clock::time_point()) {
        node.createdAt = now;
    }
    node.updatedAt = now;

    std::unique_lock<std::shared_mutex> lock(mutex_);
    const auto it = nodes_.find(node.nodeId);
    if (it != nodes_.end() && !overwrite) {
        return false;
    }

    if (it != nodes_.end() && overwrite && it->second.createdAt != std::chrono::system_clock::time_point()) {
        node.createdAt = it->second.createdAt;
    }

    nodes_[node.nodeId] = node;
    return true;
}

bool ChildNodeRegistry::updateNode(const std::string& nodeId, const ChildNodeInfo& patch) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    auto it = nodes_.find(nodeId);
    if (it == nodes_.end()) {
        return false;
    }

    ChildNodeInfo updated = it->second;
    if (!patch.name.empty()) {
        updated.name = trimString(patch.name);
    }
    if (!patch.publicAddress.empty()) {
        updated.publicAddress = trimString(patch.publicAddress);
    }
    if (patch.sshPort > 0) {
        updated.sshPort = patch.sshPort;
    }
    if (patch.clusterPort > 0) {
        updated.clusterPort = patch.clusterPort;
    }
    if (!patch.description.empty()) {
        updated.description = trimString(patch.description);
    }
    updated.enabled = patch.enabled;

    for (const auto& kv : patch.metadata) {
        if (kv.second.empty()) {
            updated.metadata.erase(kv.first);
        } else {
            updated.metadata[kv.first] = kv.second;
        }
    }

    trimNode(updated);
    if (!updated.isValid()) {
        return false;
    }

    updated.updatedAt = std::chrono::system_clock::now();
    it->second = std::move(updated);
    return true;
}

bool ChildNodeRegistry::deleteNode(const std::string& nodeId) {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    return nodes_.erase(nodeId) > 0;
}

std::optional<ChildNodeInfo> ChildNodeRegistry::getNode(const std::string& nodeId) const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    auto it = nodes_.find(nodeId);
    if (it == nodes_.end()) {
        return std::nullopt;
    }
    return it->second;
}

std::vector<ChildNodeInfo> ChildNodeRegistry::listNodes(bool enabledOnly) const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    std::vector<ChildNodeInfo> result;
    result.reserve(nodes_.size());
    for (const auto& pair : nodes_) {
        if (!enabledOnly || pair.second.enabled) {
            result.push_back(pair.second);
        }
    }

    std::sort(result.begin(), result.end(),
              [](const ChildNodeInfo& a, const ChildNodeInfo& b) {
                  return a.nodeId < b.nodeId;
              });
    return result;
}

void ChildNodeRegistry::clear() {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    nodes_.clear();
}

size_t ChildNodeRegistry::size() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return nodes_.size();
}

std::string ChildNodeRegistry::formatTimestamp(const std::chrono::system_clock::time_point& tp) {
    if (tp == std::chrono::system_clock::time_point()) {
        return "0";
    }
    const auto ts = std::chrono::duration_cast<std::chrono::seconds>(
        tp.time_since_epoch()).count();
    return std::to_string(ts);
}

std::chrono::system_clock::time_point ChildNodeRegistry::parseTimestamp(const std::string& value) {
    long long ts = 0;
    try {
        ts = std::stoll(value.empty() ? "0" : value);
    } catch (...) {
        ts = 0;
    }
    if (ts <= 0) {
        return std::chrono::system_clock::time_point();
    }
    return std::chrono::system_clock::time_point(std::chrono::seconds(ts));
}

void ChildNodeRegistry::trimNode(ChildNodeInfo& node) {
    node.nodeId = trimString(node.nodeId);
    node.name = trimString(node.name);
    node.publicAddress = trimString(node.publicAddress);
    node.description = trimString(node.description);
}

} // namespace sshjump
